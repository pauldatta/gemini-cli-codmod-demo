# Java Version Upgrade Analysis

# Table of Contents

1. [Report Metadata](#report-metadata)
1. [Summary](#summary)
1. [About this Project](#about-this-project)
    1. [Assessment Overview](#assessment-overview)
1. [Current Legacy Java Usage](#current-legacy-java-usage)
1. [Dependencies](#dependencies)
1. [Application Code Changes](#application-code-changes)
1. [Data Layer Changes](#data-layer-changes)
1. [Potential Code Enhancements](#potential-code-enhancements)
1. [Migration Plan](#migration-plan)


## Report Metadata

**Project:** src-repo

**Report ID:** CM-20251103-033331

**Generated:** Nov 3, 2025, 3:33 AM

## Summary
### Executive Summary

This report assesses the Spring PetClinic application, a monolithic Java-based system for veterinary clinic management built with Spring Boot, Java 17, and Spring Data JPA. The application features a modern technology stack and includes configurations for containerization, demonstrating a foundational readiness for cloud environments. However, its monolithic architecture and several critical issues present challenges for scalability, security, and maintainability.

### Key Findings

The analysis of the codebase has revealed several significant risks and limitations:
*   **Critical Security Vulnerabilities**: The application has hardcoded database credentials in configuration files, posing a high security risk. It also lacks Cross-Site Request Forgery (CSRF) protection due to the absence of Spring Security, leaving it vulnerable to common web attacks.
*   **Unstable Core Dependency**: The project is built on a milestone version of Spring Boot (`4.0.0-M3`), which is unsuitable for production environments due to its instability and lack of long-term support.
*   **Performance Bottlenecks**: The data access layer makes extensive use of `FetchType.EAGER` in its JPA entities. This practice leads to the "N+1 selects" problem, causing inefficient database querying and severe performance degradation under load.
*   **Architectural Coupling**: The monolithic design tightly couples all application components (owner, pet, vet management). This limits independent scaling, complicates development, and means a failure in a non-critical module could impact the entire application.

### Strategic Recommendations

To address these findings and prepare the application for a successful migration and modernization on Google Cloud, the following high-level strategies are recommended:

*   **Stabilize and Upgrade the Platform**: The immediate priority is to move from the high-risk Spring Boot milestone release to a stable, production-ready General Availability (GA) version that officially supports Java 21. This action will provide a secure and supported foundation for all other modernization efforts.
*   **Remediate Security and Performance Issues**: A focused effort is required to eliminate critical security flaws by externalizing secrets using a service like **Google Cloud Secret Manager** and integrating Spring Security to enable default protections. Concurrently, the JPA fetching strategies must be refactored to use `FetchType.LAZY` and optimized queries to resolve performance bottlenecks.
*   **Adopt a Phased Cloud Migration Strategy**: The application should be migrated to **Google Cloud** by leveraging its containerization-readiness. The recommended target architecture involves deploying the application on **Google Kubernetes Engine (GKE)** for scalable and managed orchestration, and migrating the database to **Cloud SQL** to offload operational overhead.
*   **Leverage Modern Java and Cloud-Native Features**: Post-migration, the application should be enhanced by adopting Java 21 features, such as Virtual Threads, to improve throughput. Integrating with Google Cloud's observability suite (Cloud Logging and Monitoring) and adopting structured logging will provide crucial insights for operating in a cloud environment.

### Report Information

#### Estimated Application Metrics (AI-generated)

| Metric | Value |
| :--- | :--- |
| Scanned Lines of Code (LOC) | 6,988 |
| Scanned Files | 127 |

### Generation Details

 - **Tool**: Google Cloud Code Modernization Assessment Tool v0.9.1
 - **Modelset**: gemini-2.5-pro
 - **Generated By**: pauldatta

### Command Line Options

The report was generated using the following CLI command:

 ```plaintext
/usr/local/google/home/pauldatta/CODMOD/codmod create \
    -c /usr/local/google/home/pauldatta/CODMOD/src-repo/ \
    -o spring-petclinic-java-mod.md \
    --format markdown \
    --intent JAVA_LEGACY_TO_MODERN \
    --experiments=enable_object_level_assessment
 ```

### Notice Regarding AI-Generated Assessment

 - This report leverages advanced AI for analysis, providing rapid, evidence-based insights. Please note that results are AI-derived estimates and may vary between assessments, even for the same codebase. Human review and validation are crucial for all findings and recommendations.

## About this Project
### Assessment Overview
This report provides an assessment of the effort required to upgrade the Spring PetClinic application from its current Java version to a more modern Long-Term Support (LTS) release. The analysis is based on the provided codebase structure, build configurations, and dependencies. The primary objective is to evaluate compatibility, identify necessary code and dependency changes, and outline a strategy for a successful migration.

This assessment will analyze the transition from the currently configured **Java 17** to the target **Java 21** LTS version. The source version is explicitly defined in the project's build files [^1].

The application is the **Spring PetClinic**, a well-known sample project demonstrating the capabilities of the Spring Framework. Its purpose is to model the business processes of a veterinary clinic, including managing pet owners, their pets, veterinarian information, and appointments (visits).

#### Project Characteristics

The project exhibits a modern structure and relies on the Spring ecosystem. Key characteristics identified from the codebase are summarized below:

| Characteristic | Finding |
| :--- | :--- |
| **Business Domain** | Veterinary Clinic Management |
| **Core Framework** | Spring Boot [^2] |
| **Data Persistence** | Spring Data JPA with Hibernate |
| **Web & UI** | Spring Web MVC with Thymeleaf |
| **Supported Databases** | H2 (in-memory), MySQL, PostgreSQL [^3] |
| **Build System** | Dual: Maven (`pom.xml`) and Gradle (`build.gradle`) [^4] |
| **Key Packages** | `owner`, `vet`, `visit`, `system`, `model` |
| **Deployment** | Includes configurations for Docker (`docker-compose.yml`) and Kubernetes (`k8s/`) |

#### High-Level Migration Scope

The migration from Java 17 to Java 21 is a well-defined step between two recent LTS versions. The effort is expected to be low to moderate. The primary tasks will involve:

*   Updating the Spring Boot framework to a version that officially supports Java 21.
*   Updating all other direct and transitive dependencies to ensure compatibility.
*   Executing the comprehensive test suite to validate application behavior on the new Java runtime.
*   Addressing any deprecated APIs or language features that have been removed between Java 17 and 21.

Given the project's modern architecture and reliance on Spring Boot, which generally maintains excellent backward compatibility, significant code-level refactoring is not anticipated. The main focus will be on the build configuration and dependency management. This upgrade also presents an opportunity to leverage new language features introduced in Java 21, such as virtual threads and structured concurrency, to improve application performance and maintainability, though this would be an additional scope.

[^1]: pom.xml: `<maven.compiler.release>17</maven.compiler.release>` - Specifies the Java release version for compilation.
[^2]: pom.xml: `spring-boot-starter-parent` - Identifies the project as a Spring Boot application.
[^3]: application-mysql.properties: `database=mysql` - Configuration file for MySQL profile.
[^4]: pom.xml, build.gradle: Project contains both `pom.xml` and `build.gradle` files, indicating support for both Maven and Gradle build systems.

## Current Legacy Java Usage
### Technology Stack and Architectural Analysis

This section provides an in-depth analysis of the PetClinic application's technology stack, architecture, and design patterns. While the application leverages modern frameworks, its monolithic architecture presents key considerations for modernization and migration to a cloud-native environment like Google Cloud.

#### Technology Stack Explanation

The application is built on the Spring Framework, specifically Spring Boot, which provides a robust foundation for creating stand-alone, production-grade applications. The technology stack is relatively modern and does not rely on legacy Java EE components. However, its architectural pattern is a classic monolith, which is a primary focus for modernization efforts.

The key technologies are summarized in the table below:

| Category | Technology/Framework | Version(s) | Analysis & Modernization Relevance |
| :--- | :--- | :--- | :--- |
| **Language** | Java | 17 (Runtime), 25 (Build) [^1] | The application uses a modern Java version. An upgrade from Java 17 to a newer LTS like 21 would likely be straightforward. The use of recent language features is already possible. |
| **Core Framework** | Spring Boot | 4.0.0-M3 [^2] | The use of a very recent (milestone) version of Spring Boot indicates the codebase is actively maintained and not technically a "legacy" application in terms of framework dependency. This simplifies modernization as many cloud-native features are already supported. |
| **Data Access** | Spring Data JPA, Hibernate | N/A (managed by Spring Boot) | Data access is handled via Spring Data JPA, an abstraction over an ORM (Hibernate) [^3]. This is a modern and standard approach. The application supports H2, MySQL, and PostgreSQL databases, configured via Spring profiles [^4]. |
| **Presentation Layer** | Thymeleaf, Bootstrap, WebJars | 5.3.8 (Bootstrap) [^2] | The UI is rendered server-side using Thymeleaf [^5]. This is a modern alternative to legacy technologies like JSP. The tight coupling of UI and backend logic in a monolith can be a challenge for developing separate front-end applications. |
| **APIs** | Spring MVC | N/A (managed by Spring Boot) | The application primarily functions as a traditional MVC web application. It also exposes a simple REST endpoint for veterinarian data using Spring MVC's `@ResponseBody` annotation [^6]. |
| **Caching** | JCache (JSR-107), Caffeine | N/A (managed by Spring Boot) | Caching is implemented using the standard JCache API with Caffeine as the likely provider [^7]. Caching is enabled for repository methods like `findAll` vets to improve performance [^8]. This is a solid foundation, but for a distributed system, a managed service like Memorystore would be a better fit. |
| **Build Tools** | Maven, Gradle | Maven Wrapper, Gradle 8.14.3 [^9] | The project supports both Maven and Gradle, utilizing modern wrapper scripts. This provides flexibility but indicates no single standardized build process. |
| **Containerization** | Docker, Kubernetes (Kind) | Docker Compose, Kubernetes YAML | The project includes `docker-compose.yml` for local database setup [^10] and Kubernetes manifests for deployment [^11]. This demonstrates a basic level of container awareness, which is an excellent starting point for migration to Google Kubernetes Engine (GKE). |

The codebase notably avoids common legacy technologies such as:
*   Java Enterprise Edition (Java EE) components like EJB, JSF, or JSP.
*   XML-based Spring configurations (the application uses modern annotation-based configuration).
*   Outdated data access methods like direct JDBC in business logic.

The primary "legacy" aspect is its monolithic architecture, not its technology stack.

#### Architecture Overview

The application is a classic **N-Tier monolith**. All its core functionalities—owner management, pet records, veterinarian directory, and visit scheduling—are packaged and deployed as a single Spring Boot application.

##### Key Architectural Components
The codebase is logically structured into modules based on Java packages, primarily:
-   `org.springframework.samples.petclinic.owner`: This is the largest and most central module, containing entities, controllers, and repositories for Owners, Pets, and Visits.
-   `org.springframework.samples.petclinic.vet`: A more self-contained module for managing Veterinarians and their specialties.
-   `org.springframework.samples.petclinic.system`: Handles cross-cutting concerns such as caching, error handling, and web configuration.

##### Component Interaction
Component interaction is achieved through direct, in-process method calls. For example, controllers directly invoke repository interfaces to fetch data from the database. All modules share a single database schema, which acts as the primary point of integration and coupling between them. This tight coupling is typical of a monolithic design and will be a key challenge to address during a microservices-oriented modernization.

#### APIs and Endpoints

The application exposes its functionality primarily through a server-side rendered web interface, with endpoints defined in Spring MVC controllers. It also provides a basic REST API for one of its domains.

*   **MVC Endpoints**: These form the bulk of the application's entry points and serve HTML pages rendered by Thymeleaf.
    *   `GET /owners/find`: Displays a form to search for pet owners. [^12]
    *   `GET /owners`: Processes the search and displays a list of owners or redirects to a specific owner's page. [^12]
    *   `GET /owners/{ownerId}`: Shows detailed information for a single owner. [^12]
    *   `POST /owners/new`: Handles the creation of a new owner. [^12]
    *   `GET /oups`: A dedicated endpoint to trigger an exception for testing error handling. [^13]

*   **REST Endpoints**: A single RESTful endpoint is available, which returns data in JSON format.
    *   `GET /vets`: Returns a list of all veterinarians and their specialties. This is handled by the `showResourcesVetList()` method in `VetController`, which is annotated with `@ResponseBody`. [^6]

This mixed approach of MVC and a minimal REST API is common in applications that started as traditional web apps and later added API capabilities.

#### Coupling and Dependencies

The monolithic nature of the application leads to significant coupling between its components, which is a critical factor for any modernization strategy.

*   **Data and Domain Coupling**: There is strong coupling within the `owner` package, where the `Owner`, `Pet`, and `Visit` entities are interconnected through direct object references and JPA relationships (`@OneToMany`, `@ManyToOne`) [^14][^15]. For instance, an `Owner` object contains a `List<Pet>`, and a `Pet` object contains a `Set<Visit>`. Modifying or separating one of these domains would directly impact the others. The database schema reinforces this coupling with foreign key constraints [^16].

*   **Service Layer Coupling**: Business logic is spread between controllers and entities. For example, the `Owner` entity contains methods like `addPet()` and `addVisit()`, which manipulate its internal state [^14]. While this follows a rich domain model pattern, it complicates the extraction of business logic into independent services. The `VisitController` further illustrates this by depending directly on `OwnerRepository` to load and save data that spans across owners, pets, and visits [^17].

*   **Deployment Coupling**: All features are deployed as a single unit. A failure in a minor feature, like displaying vet information, could potentially impact critical operations like managing owner records. Similarly, scaling the application means scaling all components together, even if only one part (e.g., the visits functionality) is under heavy load.

The Kubernetes deployment files define a PostgreSQL database and a single `petclinic` deployment [^11]. While containerized, this setup still deploys the application as a monolith. The database credentials are provided via a Kubernetes Secret [^18].

[^1]: pom.xml: `<maven.compiler.release>17</maven.compiler.release>` - Specifies the Java release version for the compiler.
[^2]: pom.xml: `<parent>...<version>4.0.0-M3</version></parent>` - Defines the version of the `spring-boot-starter-parent` used in the project.
[^3]: pom.xml: `<artifactId>spring-boot-starter-data-jpa</artifactId>` - Dependency for Spring Data JPA, which simplifies data access layers.
[^4]: application.properties: `database=h2` - Default database profile configuration.
[^5]: pom.xml: `<artifactId>spring-boot-starter-thymeleaf</artifactId>` - Dependency for Thymeleaf, a server-side Java template engine.
[^6]: src/main/java/org/springframework/samples/petclinic/vet/VetController.java: `showResourcesVetList()` - A method annotated with `@ResponseBody` to return vets as a JSON object.
[^7]: src/main/java/org/springframework/samples/petclinic/system/CacheConfiguration.java: `JCacheManagerCustomizer` - Configures a JCache-compliant cache named "vets".
[^8]: src/main/java/org/springframework/samples/petclinic/vet/VetRepository.java: `@Cacheable("vets")` - Annotation that enables caching for the results of the `findAll` method.
[^9]: build.gradle: `gradleVersion = "8.14.3"` - Specifies the version of Gradle to be used by the wrapper.
[^10]: docker-compose.yml: `services: mysql: ... postgres: ...` - Defines services for running MySQL and PostgreSQL databases in Docker containers for local development.
[^11]: k8s/petclinic.yml: `kind: Deployment ... name: petclinic` - Kubernetes manifest for deploying the PetClinic application.
[^12]: src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java: `@GetMapping`, `@PostMapping` - Annotations defining web endpoints for owner management.
[^13]: src/main/java/org/springframework/samples/petclinic/system/CrashController.java: `triggerException()` - A controller method that intentionally throws a `RuntimeException`.
[^14]: src/main/java/org/springframework/samples/petclinic/owner/Owner.java: `@OneToMany ... private final List<Pet> pets` - JPA annotation defining a one-to-many relationship between Owner and Pet.
[^15]: src/main/java/org/springframework/samples/petclinic/owner/Pet.java: `@OneToMany ... private final Set<Visit> visits` - JPA annotation defining a one-to-many relationship between Pet and Visit.
[^16]: src/main/resources/db/h2/schema.sql: `ALTER TABLE pets ADD CONSTRAINT fk_pets_owners FOREIGN KEY (owner_id) REFERENCES owners (id);` - SQL statement creating a foreign key to link the pets and owners tables.
[^17]: src/main/java/org/springframework/samples/petclinic/owner/VisitController.java: `private final OwnerRepository owners;` - The controller for visits directly uses the owner repository to manage data.
[^18]: k8s/db.yml: `password: "pass"` - A Kubernetes Secret containing database credentials. For security, this value should be managed outside of version control.

## Dependencies
This section details the project's dependencies, their compatibility with the planned Java 21 upgrade, and recommendations for ensuring a stable and supportable technology stack. The analysis is based on the `pom.xml` and `build.gradle` files found in the codebase.

### Dependency Analysis Summary

The project is already utilizing a modern technology stack, with build configurations targeting Java 25 and a runtime release target of Java 17 [^1][^2]. The application is built upon a milestone version of Spring Boot (`4.0.0-M3`), which indicates it is aligned with forward-looking development practices but also introduces risk for a production environment.

The primary focus for modernization is not a large-scale upgrade from an archaic stack, but rather the stabilization of the existing dependencies to ensure they are production-ready, fully compatible with Java 21, and supported for long-term maintenance. The key recommendation is to align the project with a stable, General Availability (GA) version of Spring Boot 3.x, which provides official support for Java 21.

### Build System and Java Version

The project can be built using either Apache Maven or Gradle. Both build files define a modern Java version but with a slight inconsistency between the toolchain/build version (Java 25) and the runtime release target (Java 17).

| Tool | Configuration File | Java Build Version | Java Runtime Target |
| :--- | :--- | :--- | :--- |
| Maven | `pom.xml` | `25` (via `<java.version>`) | `17` (via `<maven.compiler.release>`) |
| Gradle | `build.gradle` | `25` (via `toolchain`) | `17` (via `options.release`) |

For the migration to Google Cloud and standardization on Java 21, it is recommended to unify these versions. Setting both the build and runtime target to Java 21 will simplify the toolchain and ensure the application is compiled and tested against the intended production environment.

### External Dependency Analysis

The project leverages the Spring Boot dependency management system, which centralizes version control for a wide range of libraries. The most critical dependency is the `spring-boot-starter-parent` itself.

#### Key Dependencies and Recommendations

| Component | Group ID | Artifact ID | Current Version | Assessment for Java 21 | Recommendation |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Spring Boot** | `org.springframework.boot` | `spring-boot-starter-parent` | `4.0.0-M3` [^1][^2] | **High Risk**. Milestone releases are not suitable for production. They are unstable and lack long-term support. | **Downgrade to the latest stable Spring Boot 3.3.x release.** This provides official Java 21 support, security patches, and a stable foundation for all transitive dependencies. |
| **Java Caching API** | `javax.cache` | `cache-api` | `1.1.1` (managed) | Compatible. This is a standard API (JSR-107) and is supported. | No change needed. Spring Boot provides the implementation via Caffeine. |
| **Java XML Binding** | `jakarta.xml.bind` | `jakarta.xml.bind-api` | `4.0.0` (managed) | **Best Practice**. The project correctly uses the `jakarta.*` namespace, which is required for Java 11+ as this API was removed from the JDK. | No change needed. |
| **Testcontainers** | `org.testcontainers` | `junit-jupiter`, `mysql` | `1.19.8` (managed) | Compatible. Testcontainers is well-maintained and supports modern Java versions. | No change needed. Version will be updated automatically with the parent POM. |
| **GraalVM Native Build Tools** | `org.graalvm.buildtools` | `native-maven-plugin` | `0.10.2` (managed)| Compatible. Required for building GraalVM native images. | No change needed. Ensure the version aligns with the target GraalVM SDK. |

#### Full Dependency List

The following table outlines the main dependencies declared in the project. Most versions are managed by the `spring-boot-starter-parent` POM.

| Group ID | Artifact ID | Declared Version | Scope | Purpose |
| :--- | :--- | :--- | :--- | :--- |
| `org.springframework.boot` | `spring-boot-starter-actuator` | Managed by Parent | Implementation | Monitoring and management |
| `org.springframework.boot` | `spring-boot-starter-data-jpa` | Managed by Parent | Implementation | Data access with JPA/Hibernate |
| `org.springframework.boot` | `spring-boot-starter-thymeleaf` | Managed by Parent | Implementation | Server-side templating |
| `org.springframework.boot` | `spring-boot-starter-web` | Managed by Parent | Implementation | Web framework (Spring MVC) |
| `com.h2database` | `h2` | Managed by Parent | Runtime | In-memory database |
| `com.mysql` | `mysql-connector-j` | Managed by Parent | Runtime | MySQL database driver |
| `org.postgresql` | `postgresql` | Managed by Parent | Runtime | PostgreSQL database driver |
| `com.github.ben-manes.caffeine` | `caffeine` | Managed by Parent | Implementation | Caching provider |
| `org.webjars.npm` | `bootstrap` | `${webjars-bootstrap.version}` | Runtime | Frontend CSS/JS framework |
| `org.springframework.boot` | `spring-boot-starter-test` | Managed by Parent | Test | Core testing utilities |
| `org.springframework.boot` | `spring-boot-testcontainers` | Managed by Parent | Test | Integration with Testcontainers |
| `org.testcontainers` | `junit-jupiter` | Managed by Parent | Test | JUnit 5 support for Testcontainers |

### Internal Project Dependencies

The Spring PetClinic application is a **single-module project**. As such, there are no complex internal dependencies between modules. The entire application is built and deployed as a single artifact (`.jar` file). This simplifies the build process and dependency management, as there is no need to coordinate upgrades across multiple internal modules.

### Summary and Recommendations

1.  **Stabilize Spring Boot Version**: The immediate priority is to move from the `4.0.0-M3` milestone to a production-ready GA release.
    *   **Action**: Change the parent POM version in `pom.xml` and the plugin version in `build.gradle` to the latest stable **Spring Boot 3.3.x**. This will align all transitive dependencies to stable, Java 21-compatible versions.

2.  **Unify Java Version**: Standardize the Java version across all build configurations to match the target runtime.
    *   **Action**: In `pom.xml`, set `<java.version>21</java.version>` and ensure `<maven.compiler.release>` is either removed or also set to `21`. In `build.gradle`, set both `languageVersion` and `options.release` to `21`.

3.  **Leverage Managed Dependencies**: Continue to rely on Spring Boot's curated dependency management. Avoid overriding versions for libraries like Hibernate, Jackson, or database drivers unless absolutely necessary. The recommended parent POM update will handle this.

4.  **Review Native Image Compatibility**: While the project is configured for GraalVM, migrating to a stable Spring Boot version may require re-validating native test execution. The support for native images is robust in Spring Boot 3.x, but it's crucial to test thoroughly after the version change.

By implementing these changes, the project will be on a stable, secure, and modern foundation, making it well-prepared for migration to Google Cloud and future development efforts.

[^1]: pom.xml: `<parent>` - Defines the Spring Boot starter parent, which manages dependency versions for the project.
[^2]: build.gradle: `plugins` - Declares the Spring Boot Gradle plugin and its version.

## Application Code Changes
This section details the code modifications, security considerations, and performance optimizations necessary to upgrade the application to Java 21. The codebase is already on a modern version of Java (targeting Java 17) and utilizes Spring Boot 3, meaning many of the significant breaking changes from older Java versions (like the `javax` to `jakarta` migration) have already been addressed. The focus here is on the final steps to reach Java 21, addressing remaining security and performance issues, and leveraging new language features.

### Required Code Transformations and Upgrade Guidance

The application is well-positioned for an upgrade to Java 21, as it already uses `jakarta` namespaces and dependencies compatible with modern Java versions. The required code transformations are minimal and primarily involve adopting new language features for improved readability and correctness.

#### Java EE Module Migration (`javax` to `jakarta`)

The application has successfully migrated from the legacy `javax.*` packages to the `jakarta.*` packages, which is a mandatory step for running on modern Java runtimes with Spring Boot 3.

*   **JPA and Validation:** The codebase correctly uses `jakarta.persistence.*` and `jakarta.validation.*` for its entity models and validation constraints [^1].
*   **XML Binding:** The project correctly includes the `jakarta.xml.bind-api` dependency and uses `jakarta.xml.bind.*` annotations for XML serialization in the `Vets` and `Vet` classes [^2], which is necessary as JAXB is no longer part of the standard JDK.

This proactive migration significantly reduces the effort for the final upgrade to Java 21.

| Finding | Status | Complexity | Effort |
| :--- | :--- | :--- | :--- |
| Migration from `javax` to `jakarta` namespaces | **Completed** | N/A | N/A |

<br/>

#### Modern Java Language Feature Adoption

The codebase can be refactored to use modern language features introduced in recent Java versions, improving conciseness and maintainability.

**1. Pattern Matching for `instanceof`**

The code contains several instances of casting an object after an `instanceof` check. This can be simplified using pattern matching, which became standard in Java 16.

*   **File**: `src/main/java/org/springframework/samples/petclinic/owner/PetValidator.java`
*   **Guidance**: Refactor the `validate` method to use a pattern variable, which combines the type check and casting into a single, safer operation.

**Before:**
```java
@Override
public void validate(Object obj, Errors errors) {
    Pet pet = (Pet) obj;
    String name = pet.getName();
    // ...
}
```

**After:**
```java
@Override
public void validate(Object obj, Errors errors) {
    if (obj instanceof Pet pet) {
        String name = pet.getName();
        // ...
    }
}
```

**2. Bug Fix and Refactoring in `EntityUtils`**

The `EntityUtils.getById` method contains a potential bug and can be refactored for clarity.

*   **File**: `src/test/java/org/springframework/samples/petclinic/service/EntityUtils.java`
*   **Guidance**:
    1.  The comparison `entity.getId() == entityId` is a bug when dealing with `Integer` objects above the cache range (-128 to 127). It should be replaced with `.equals()` for safe object comparison.
    2.  The `entityClass.isInstance(entity)` check is redundant because the method signature already guarantees that all items in the `entities` collection are of type `T`.

**Before:**
```java
public static <T extends BaseEntity> T getById(Collection<T> entities, Class<T> entityClass, int entityId)
        throws ObjectRetrievalFailureException {
    for (T entity : entities) {
        if (entity.getId() != null && entity.getId() == entityId && entityClass.isInstance(entity)) {
            return entity;
        }
    }
    throw new ObjectRetrievalFailureException(entityClass, entityId);
}
```

**After:**
```java
public static <T extends BaseEntity> T getById(Collection<T> entities, Class<T> entityClass, int entityId)
        throws ObjectRetrievalFailureException {
    for (T entity : entities) {
        // Use .equals() for robust Integer comparison and remove redundant type check
        if (entity.getId() != null && entity.getId().equals(entityId)) {
            return entity;
        }
    }
    throw new ObjectRetrievalFailureException(entityClass, entityId);
}
```

| Finding | Recommendation | Complexity | Effort |
| :--- | :--- | :--- | :--- |
| Use of older `instanceof` and cast pattern | Refactor to use Pattern Matching for `instanceof` | Low | Small |
| Potential bug with `==` on `Integer` objects | Replace `==` with `.equals()` for object comparison | Low | Small |

### Security Issues and Recommendations

Upgrading to Java 21 is an excellent opportunity to address existing security vulnerabilities and adopt modern security practices.

#### Hardcoded Secrets

The repository contains hardcoded database credentials in multiple configuration files. This poses a significant security risk, as secrets are exposed in source control.

*   **Files**:
    *   `k8s/db.yml`: Contains `username: "user"` and `password: "pass"` [^3].
    *   `src/main/resources/application-mysql.properties`: Contains `spring.datasource.username=${MYSQL_USER:petclinic}` and `spring.datasource.password=${MYSQL_PASS:******}` [^4].
    *   `src/main/resources/application-postgres.properties`: Contains `spring.datasource.username=${POSTGRES_USER:petclinic}` and `spring.datasource.password=${POSTGRES_PASS:******}` [^5].
*   **Recommendation**: All secrets must be removed from the codebase and externalized. For the target Google Cloud environment, **Google Cloud Secret Manager** is the recommended solution. The application can be configured to fetch secrets at runtime, eliminating them from version control.

#### Missing CSRF Protection

The application does not include Spring Security as a dependency, which means it lacks default protections against common web vulnerabilities like Cross-Site Request Forgery (CSRF). POST endpoints for creating and updating data are vulnerable.

*   **Files**: `pom.xml`, `build.gradle` (lack of `spring-boot-starter-security`).
*   **Recommendation**: Add the `spring-boot-starter-security` dependency. This will enable CSRF protection by default. Forms submitted via POST will need to include the CSRF token, which Thymeleaf can do automatically when configured correctly.

#### Outdated Frontend Dependencies

The project uses an old version of Font-Awesome, which has known vulnerabilities.

*   **File**: `pom.xml` specifies `<webjars-font-awesome.version>4.7.0</webjars-font-awesome.version>` [^6].
*   **Recommendation**: Upgrade `font-awesome` to the latest version to patch known security issues. Alternatively, migrate to a more modern icon library.

| Finding | Recommendation | Severity | Complexity | Effort |
| :--- | :--- | :--- | :--- | :--- |
| Hardcoded Credentials | Externalize secrets using **Google Cloud Secret Manager** | **High** | Medium | Medium |
| Missing CSRF Protection | Integrate Spring Security to enable default CSRF protection | **High** | Medium | Medium |
| Vulnerable `font-awesome` library | Upgrade to the latest version or replace | Medium | Low | Small |
| Use of Milestone Spring Boot Version | Use only stable, supported Spring Boot releases for production | Medium | Low | Small |

### Performance Bottlenecks and Optimization

The following patterns were identified as potential sources of performance issues.

#### Inefficient JPA Fetching Strategy

Several JPA entities use `FetchType.EAGER` for collection-based relationships. This can lead to the "N+1 selects" problem, where fetching a list of entities results in numerous additional database queries to load their associated collections, severely degrading performance.

*   **Files**:
    *   `Owner.java`: The `pets` collection is fetched eagerly (`fetch = FetchType.EAGER`) [^7].
    *   `Pet.java`: The `visits` collection is fetched eagerly (`fetch = FetchType.EAGER`) [^8].
    *   `Vet.java`: The `specialties` collection is fetched eagerly (`fetch = FetchType.EAGER`) [^9].
*   **Recommendation**: Change all `@OneToMany` and `@ManyToMany` relationships to use `FetchType.LAZY`. For use cases that require these collections, create dedicated repository methods with `@Query` annotations that use a `JOIN FETCH` clause to load the data in a single, efficient query.

#### Leverage Virtual Threads (Java 21)

The application follows a traditional thread-per-request model. With Java 21, it can be easily configured to use Virtual Threads to dramatically improve scalability and throughput with minimal code changes.

*   **Recommendation**: Enable virtual threads by setting the following property in `application.properties`:
    ```properties
    spring.threads.virtual.enabled=true
    ```
    This will configure the embedded Tomcat server to use virtual threads for handling incoming HTTP requests, allowing the application to handle a much larger number of concurrent connections.

| Finding | Recommendation | Impact | Complexity | Effort |
| :--- | :--- | :--- | :--- | :--- |
| Eager fetching in JPA entities | Change fetch types to `LAZY` and use `JOIN FETCH` in queries | **High** | Medium | Medium |
| Sorting a collection on every access | Cache the sorted list if data is mostly static | Low | Low | Small |
| Opportunity to use Virtual Threads | Enable `spring.threads.virtual.enabled` in configuration | **High** | Low | Small |

<br>
***
[^1]: src/main/java/org/springframework/samples/petclinic/owner/Owner.java: @Entity - The file uses `jakarta.persistence.Entity` and other JPA annotations.
[^2]: src/main/java/org/springframework/samples/petclinic/vet/Vets.java: @XmlRootElement - The file uses `jakarta.xml.bind.annotation.XmlRootElement` and `@XmlElement`.
[^3]: k8s/db.yml: password - The file contains a hardcoded password for the PostgreSQL database deployment.
[^4]: src/main/resources/application-mysql.properties: spring.datasource.password - The file defines a default password for the MySQL profile.
[^5]: src/main/resources/application-postgres.properties: spring.datasource.password - The file defines a default password for the PostgreSQL profile.
[^6]: pom.xml: webjars-font-awesome.version - The property defines the version for the Font-Awesome webjar.
[^7]: src/main/java/org/springframework/samples/petclinic/owner/Owner.java: @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER) - The `pets` collection is configured to be fetched eagerly.
[^8]: src/main/java/org/springframework/samples/petclinic/owner/Pet.java: @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER) - The `visits` collection is configured to be fetched eagerly.
[^9]: src/main/java/org/springframework/samples/petclinic/vet/Vet.java: @ManyToMany(fetch = FetchType.EAGER) - The `specialties` collection is configured to be fetched eagerly.

## Data Layer Changes
### Data Layer Analysis

This section analyzes the application's data access layer, its core technologies, and the implications of migrating to a modern Java runtime. The assessment covers database dependencies, required code modifications, and potential optimizations.

#### Data Access Technologies

The application employs a modern and standardized data access stack, primarily built on Spring Data JPA. This provides a high level of abstraction over the underlying database, simplifying data persistence and retrieval logic.

The key technologies identified are summarized below:

| Technology / Component | Library / Framework | Version | Role & Analysis |
| :--- | :--- | :--- | :--- |
| **ORM Framework** | Spring Data JPA / Hibernate | Managed by Spring Boot 4.0.0-M3 | The core of the data access layer. It uses the Repository pattern (`JpaRepository`) to abstract away boilerplate CRUD operations [^1]. Hibernate is the default persistence provider. |
| **Database Drivers** | H2 Database Engine | Managed by Spring Boot | Used as the default, in-memory database for local development and testing, simplifying the setup process [^2]. |
| | MySQL JDBC Driver | `mysql-connector-j` | Provides connectivity to MySQL databases. The application can be configured to use MySQL via a Spring profile [^3]. |
| | PostgreSQL JDBC Driver | `postgresql` | Provides connectivity to PostgreSQL databases. The application can be configured to use PostgreSQL via a Spring profile [^4]. |
| **Connection Pooling** | HikariCP | Managed by Spring Boot | Spring Boot automatically configures HikariCP, a high-performance JDBC connection pool, when `spring-boot-starter-data-jpa` is used. |
| **Caching** | JCache (JSR-107) API | `javax.cache:cache-api` | Used for caching database query results, specifically for veterinarian data, to improve performance [^5]. |
| **Cache Implementation**| Caffeine | `com.github.ben-manes.caffeine` | A high-performance, modern caching library used as the backing implementation for JCache [^6]. |

#### Dependency Compatibility Analysis

The project is configured with `spring-boot-starter-parent` version `4.0.0-M3`, which ensures that all transitive dependencies, including data access libraries, are managed and aligned with modern Java runtimes like Java 21.

*   **JDBC Drivers**: The versions of the H2, MySQL, and PostgreSQL drivers pulled in by the Spring Boot dependency management are fully compatible with Java 21. No compatibility issues are anticipated.
*   **Connection Pooling**: HikariCP is the default connection pool in Spring Boot and is actively maintained. The version included is compatible with Java 21.
*   **JPA & Hibernate**: Spring Boot 4.0.0-M3 relies on versions of Hibernate and Spring Data that are built for the `jakarta.*` namespace and are designed to run on the latest Java LTS versions.

No dependency upgrades are strictly required for Java 21 compatibility, as the build system already uses a modern technology stack.

#### Code Changes and Modernization

The most significant change required when migrating a legacy Java 8 application to Java 21 and Spring Boot 3+ is the transition from Java EE (`javax.*`) to Jakarta EE (`jakarta.*`). Analysis of the codebase confirms that this migration has already been completed.

##### Jakarta EE Namespace Migration

The application's source code consistently uses the `jakarta.*` namespace for persistence-related imports, which is the standard for modern Java enterprise applications. This indicates the application is already aligned with Spring Framework 6 / Spring Boot 3 and later.

For example, JPA entities and validation constraints use the correct `jakarta` imports:
*   `jakarta.persistence.Entity` in `Owner.java` [^7].
*   `jakarta.persistence.MappedSuperclass` in `BaseEntity.java` [^8].
*   `jakarta.validation.constraints.NotBlank` in `Person.java` [^9].

The table below illustrates the namespace changes that have been correctly applied to this codebase.

| Old `javax.*` Annotation (Legacy) | New `jakarta.*` Annotation (Current) |
| :--- | :--- |
| `javax.persistence.Entity` | `jakarta.persistence.Entity` |
| `javax.persistence.Id` | `jakarta.persistence.Id` |
| `javax.persistence.GeneratedValue` | `jakarta.persistence.GeneratedValue` |
| `javax.persistence.OneToMany` | `jakarta.persistence.OneToMany` |
| `javax.validation.Valid` | `jakarta.validation.Valid` |
| `javax.validation.constraints.NotBlank` | `jakarta.validation.constraints.NotBlank` |

No further code changes related to namespace migration are necessary.

#### Optimization and Best Practices

While the data layer is modern, there are opportunities for performance tuning and applying best practices.

##### Review Eager Fetching Strategies

Several entities in the application use `FetchType.EAGER`, which can lead to performance issues, most notably the "N+1 select" problem. In this scenario, fetching a list of primary entities (e.g., N owners) triggers an additional database query for each entity to fetch its eagerly-loaded collection.

*   **Owner Entity**: The `pets` collection is fetched eagerly [^10]. When a list of owners is retrieved, this will trigger a separate query for each owner to load their pets.
*   **Vet Entity**: The `specialties` collection is also fetched eagerly [^11].
*   **Pet Entity**: The `visits` collection is fetched eagerly [^12].

**Recommendation:**
Change the fetch type for these collections to `FetchType.LAZY`. This is the default and recommended strategy for collections. Data for lazy collections is only loaded from the database when explicitly accessed. This change would require a review of repository methods and service logic to ensure that collections are initialized correctly when needed, for example, by using `JOIN FETCH` in JPQL queries or using Entity Graphs.

```java
// Example Recommendation in Owner.java
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY) // Changed from EAGER
@JoinColumn(name = "owner_id")
@OrderBy("name")
private final List<Pet> pets = new ArrayList<>();
```

##### Caching Mechanism

The application correctly implements caching for the veterinarian list, which is a relatively static dataset [^5]. It uses the standard JCache API with Caffeine, a high-performance implementation. This is an excellent practice that reduces database load for frequently accessed, non-volatile data. This caching strategy should be maintained and considered for other appropriate entities.

##### Effective Use of Pagination

The controllers for listing owners and vets properly use Spring Data's `Pageable` and `Page` interfaces [^13] [^14]. This is a crucial performance best practice, as it prevents loading an entire table into memory and instead retrieves data in manageable chunks. This approach scales well and should be the standard for any feature that returns a list of entities.

[^1]: src/main/java/org/springframework/samples/petclinic/owner/OwnerRepository.java: `public interface OwnerRepository extends JpaRepository<Owner, Integer>` - Defines a Spring Data repository for Owner entities.
[^2]: src/main/resources/application.properties: `database=h2` - Sets the default database profile to H2.
[^3]: src/main/resources/application-mysql.properties: `spring.datasource.url=${MYSQL_URL:jdbc:mysql://localhost/petclinic}` - Configuration file for the MySQL database profile.
[^4]: src/main/resources/application-postgres.properties: `spring.datasource.url=${POSTGRES_URL:jdbc:postgresql://localhost/petclinic}` - Configuration file for the PostgreSQL database profile.
[^5]: src/main/java/org/springframework/samples/petclinic/system/CacheConfiguration.java: `cm.createCache("vets", cacheConfiguration())` - Programmatically creates a cache named "vets".
[^6]: build.gradle: `runtimeOnly 'com.github.ben-manes.caffeine:caffeine'` - Declares the Caffeine dependency for caching.
[^7]: src/main/java/org/springframework/samples/petclinic/owner/Owner.java: `@Entity` - Marks the Owner class as a JPA entity, using the `jakarta.persistence` namespace.
[^8]: src/main/java/org/springframework/samples/petclinic/model/BaseEntity.java: `@MappedSuperclass` - Defines a base class for entities, using the `jakarta.persistence` namespace.
[^9]: src/main/java/org/springframework/samples/petclinic/model/Person.java: `@NotBlank` - Applies a validation constraint from the `jakarta.validation` namespace.
[^10]: src/main/java/org/springframework/samples/petclinic/owner/Owner.java: `@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)` - The `pets` collection is configured to be fetched eagerly.
[^11]: src/main/java/org/springframework/samples/petclinic/vet/Vet.java: `@ManyToMany(fetch = FetchType.EAGER)` - The `specialties` collection is configured to be fetched eagerly.
[^12]: src/main/java/org/springframework/samples/petclinic/owner/Pet.java: `@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)` - The `visits` collection is configured to be fetched eagerly.
[^13]: src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java: `findPaginatedForOwnersLastName(int page, String lastname)` - Method uses `Pageable` to fetch a paginated list of owners.
[^14]: src/main/java/org/springframework/samples/petclinic/vet/VetController.java: `findPaginated(int page)` - Method uses `Pageable` to fetch a paginated list of vets.

## Potential Code Enhancements
Following the initial migration to a modern Java version, the PetClinic application is well-positioned for a series of enhancements that can further improve its performance, maintainability, and developer experience. This section outlines key opportunities for modernization, leveraging features of the new Java platform and contemporary software development practices.

#### Leveraging New Java Language Features

The existing codebase, while functional, can be significantly refined by adopting modern Java language features. These changes can lead to more concise, readable, and robust code.

##### Refactor Data Transfer Objects (DTOs) with Java Records

Many of the model classes in the application serve as simple, immutable data carriers. These are ideal candidates for refactoring into Java Records, which automatically generate constructors, `equals()`, `hashCode()`, and `toString()` methods, reducing boilerplate code significantly.

While entities like `Owner` and `Pet` are stateful and part of a JPA inheritance structure (`BaseEntity`, `Person`), other classes are simpler. For example, `Specialty` and `PetType` are excellent candidates. The `Vets` class, which acts as a wrapper for a list, can also be refactored [^1].

**Example: Refactoring `Vets` Wrapper Class**

*Before (Current approach):*
A mutable class is used to wrap a list for XML/JSON serialization.

```java
// src/main/java/org/springframework/samples/petclinic/vet/Vets.java
@XmlRootElement
public class Vets {

    private @Nullable List<Vet> vets;

    @XmlElement
    public List<Vet> getVetList() {
        if (vets == null) {
            vets = new ArrayList<>();
        }
        return vets;
    }
}
```

*After (Using a Record):*
A `record` provides an immutable and concise representation.

```java
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;
import java.util.List;

@XmlRootElement(name = "vets")
public record Vets(@XmlElement(name = "vet") List<Vet> vetList) {
    public Vets() {
        this(new ArrayList<>());
    }
}
```

##### Simplify Code with Pattern Matching for `instanceof`

The codebase contains several instances of casting after an `instanceof` check. Java's pattern matching for `instanceof` can eliminate this redundancy, making the code safer and more readable.

**Example: Simplifying the `PetValidator`** [^2]

*Before:*

```java
// src/main/java/org/springframework/samples/petclinic/owner/PetValidator.java
@Override
public void validate(Object obj, Errors errors) {
    Pet pet = (Pet) obj;
    String name = pet.getName();
    // ... validation logic
}
```

*After:*

```java
// src/main/java/org/springframework/samples/petclinic/owner/PetValidator.java
@Override
public void validate(Object obj, Errors errors) {
    if (obj instanceof Pet pet) {
        String name = pet.getName();
        // ... validation logic
    }
}
```

##### Adopt `var` for Local Variable Type Inference

Using `var` for local variables can reduce verbosity where the type is clear from the initializer, improving readability by focusing on the variable's name and purpose.

**Example: Cleaning up Controller Logic** [^3]

*Before:*

```java
// src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java
private String addPaginationModel(int page, Model model, Page<Owner> paginated) {
    List<Owner> listOwners = paginated.getContent();
    model.addAttribute("currentPage", page);
    //...
    return "owners/ownersList";
}
```

*After:*

```java
// src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java
private String addPaginationModel(int page, Model model, Page<Owner> paginated) {
    var listOwners = paginated.getContent();
    model.addAttribute("currentPage", page);
    //...
    return "owners/ownersList";
}
```

##### Utilize Virtual Threads for Enhanced Concurrency

The application follows a traditional thread-per-request model, which is standard for Spring MVC applications [^4]. While effective, this can become a bottleneck under high load, as each concurrent request consumes a platform thread.

With Java 21, Virtual Threads (from Project Loom) offer a powerful alternative. By using virtual threads, the application can handle many more concurrent I/O-bound operations (like database queries) with a small number of platform threads. Migrating the Spring Boot application to use virtual threads is often as simple as enabling a configuration property:

```properties
spring.threads.virtual.enabled=true
```

This is a low-effort, high-impact enhancement to investigate post-migration for improving application throughput and scalability.

#### Modernize Build and CI/CD

The project utilizes both Maven and Gradle, along with GitHub Actions for CI/CD [^5] [^6]. These can be further optimized.

##### Build System Enhancements

| Area | Recommendation | Benefit |
| :--- | :--- | :--- |
| **Build Plugins** | Ensure the latest versions of `spring-boot-maven-plugin` or the Gradle equivalent are used. | Access to the latest features for creating optimized container images, AOT processing, and more. |
| **Dependency Management** | Regularly run `mvn versions:display-dependency-updates` or `gradle dependencyUpdates` to identify outdated dependencies. | Security and performance improvements from using up-to-date libraries. |
| **Containerization** | The project already uses Spring Boot's build image support (`spring-boot:build-image`), which leverages Cloud Native Buildpacks. This is an excellent practice. | Creates optimized, layered Docker images without needing a `Dockerfile`, improving build times and security. |

##### CI/CD Pipeline Recommendations

-   **Multi-Stage Docker Builds:** For projects that require a `Dockerfile`, a multi-stage build is essential for creating lean and secure production images. This separates the build environment from the runtime environment.

    ```dockerfile
    # Stage 1: Build the application
    FROM eclipse-temurin:21-jdk as builder
    WORKDIR /app
    COPY . .
    RUN ./mvnw package -DskipTests

    # Stage 2: Create the final, minimal runtime image
    FROM eclipse-temurin:21-jre-alpine
    WORKDIR /app
    COPY --from=builder /app/target/*.jar app.jar
    ENTRYPOINT ["java", "-jar", "app.jar"]
    ```

-   **Security Scanning:** Integrate automated security scanning into the CI pipeline. Tools like **Trivy**, **Snyk**, or **GitHub's Dependabot** can scan dependencies and container images for known vulnerabilities before deployment.

-   **Cache Build Artifacts:** The existing GitHub Actions workflows already cache Maven dependencies [^7]. This practice should be maintained and extended to other stages (e.g., Docker layers) to accelerate pipeline execution.

#### Improve Logging and Monitoring

Effective observability is crucial for applications running in the cloud.

##### Adopt Structured Logging

The current logging configuration outputs plain text, which is difficult for automated systems to parse. Adopting **structured logging** (e.g., JSON) provides a machine-readable format that integrates seamlessly with log management platforms like Google Cloud Logging.

**Recommendation:**
Use a library like `logstash-logback-encoder` to configure Logback (Spring Boot's default logging backend) to output logs in JSON format.

*Example `logback-spring.xml` Configuration:*
```xml
<configuration>
    <appender name="jsonConsoleAppender" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LogstashEncoder" />
    </appender>

    <root level="INFO">
        <appender-ref ref="jsonConsoleAppender" />
    </root>
</configuration>
```

This small change enables powerful querying, alerting, and dashboarding capabilities based on log content.

##### Leverage Application Metrics with Micrometer

The application already includes `spring-boot-starter-actuator`, which exposes valuable metrics [^8]. By adding the `micrometer-registry-stackdriver` dependency, these metrics can be automatically exported to **Google Cloud Monitoring**. This provides deep insights into:
-   JVM health (GC performance, memory usage, thread counts).
-   Application performance (HTTP request latency, error rates).
-   Resource utilization (database connection pool usage).

#### Optimize Memory Management and GC

Modern Java versions offer more advanced Garbage Collectors (GC) and better memory management, especially for containerized environments.

##### Garbage Collector Selection

| Collector | Default In | Best For | Description |
| :--- | :--- | :--- | :--- |
| **Parallel GC** | Java 8 | Throughput-heavy batch jobs | A multi-threaded "stop-the-world" collector that prioritizes throughput over low latency. |
| **G1GC** | Java 9+ | General purpose, balanced performance | The default in modern Java. It divides the heap into regions to minimize pause times while maintaining good throughput. |
| **ZGC / Shenandoah** | Available in Java 21 | Ultra-low-latency applications | Concurrent collectors that perform most of their work while application threads are running, resulting in pause times of less than a millisecond. |

**Recommendation:** Start with the default **G1GC**, which is a robust choice for most web applications. If the application proves to be highly sensitive to latency, evaluate **ZGC** or **Shenandoah** as a post-migration optimization.

##### JVM Tuning for Containers

Hardcoding heap sizes (e.g., `-Xmx2G`) is an anti-pattern in containerized environments. Modern JVMs are container-aware and can dynamically size the heap based on the container's memory limits.

**Recommendation:**
Use percentage-based flags to allow the JVM to adapt to its container environment. These should be set in the application's entrypoint or Dockerfile.

```bash
### Example JVM options for a containerized application
-XX:MaxRAMPercentage=80.0
-XX:InitialRAMPercentage=50.0
-XX:+UseG1GC
-XX:+ExitOnOutOfMemoryError
```
This configuration ensures the application makes efficient use of allocated resources and behaves predictably within its container.

[^1]: src/main/java/org/springframework/samples/petclinic/vet/Vets.java: `Vets` - A wrapper class for a list of Vet objects, suitable for refactoring into a record.
[^2]: src/main/java/org/springframework/samples/petclinic/owner/PetValidator.java: `validate` - This method performs an unsafe cast `(Pet) obj` which can be improved with pattern matching.
[^3]: src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java: `addPaginationModel` - Method uses explicit type declaration `List<Owner> listOwners = paginated.getContent();` where `var` could be used.
[^4]: src/main/java/org/springframework/samples/petclinic/owner/OwnerController.java: `@Controller` - This class and others like it handle web requests, which by default in Spring MVC are processed using a thread-per-request model.
[^5]: pom.xml: `pom.xml` - The project's Maven build configuration file.
[^6]: .github/workflows/maven-build.yml: `maven-build.yml` - A GitHub Actions workflow for building the project with Maven.
[^7]: .github/workflows/maven-build.yml: `cache: maven` - The workflow uses the `setup-java` action with Maven caching enabled to speed up builds.
[^8]: pom.xml: `<artifactId>spring-boot-starter-actuator</artifactId>` - The dependency that enables monitoring and management endpoints.

## Migration Plan
### Migration Roadmap

This roadmap outlines a phased, iterative approach to migrating the Spring PetClinic application to Java 21. The project already utilizes modern Java features and build configurations, targeting a Java 17 release compiled with JDK 25 [^1][^2]. The migration will therefore focus on standardizing the environment to Java 21, updating dependencies, and preparing the application for robust deployment on Google Cloud.

| Phase | Title | Description | Key Objectives |
| :-- | :--- | :--- | :--- |
| **1** | **Preparation & Environment Standardization** | Establish a consistent Java 21 development and build environment. This involves updating build tools, CI/CD pipelines, and base container images. The dual Maven and Gradle setup will be reviewed for potential consolidation. | ▸ Standardize on JDK 21 for all builds and tests.<br>▸ Update build tool wrappers and plugins.<br>▸ Align container images with the Java 21 runtime. |
| **2** | **Dependency & Framework Alignment** | Update the Spring Boot framework and all third-party libraries to versions that are fully compatible with Java 21. This phase is critical for ensuring stability and leveraging the latest framework features. | ▸ Upgrade to a stable, Java 21-compatible Spring Boot version.<br>▸ Audit and update all dependencies.<br>▸ Resolve any breaking changes from library upgrades. |
| **3** | **Code Refactoring & Modernization** | Address any code-level incompatibilities and begin adopting modern Java 21 features. Since the codebase is already on a recent version, this phase will focus more on enhancement than remediation. | ▸ Remediate any deprecated code identified by static analysis.<br>▸ Explore adopting Java 21 features like Virtual Threads.<br>▸ Ensure Native Image compatibility is maintained. |
| **4** | **Comprehensive Testing** | Validate the migrated application's functionality, performance, and security. Thorough testing at this stage is crucial to de-risk the production rollout. | ▸ Achieve 100% pass rate on all existing tests.<br>▸ Conduct performance benchmarks against the baseline.<br>▸ Perform security scans on new dependencies and code. |
| **5** | **Deployment & Post-Migration on Google Cloud** | Deploy the migrated application to Google Cloud, monitor its behavior, and plan for future enhancements. This phase transitions the application to its new production environment. | ▸ Deploy successfully to a staging GKE cluster.<br>▸ Execute a safe production rollout (e.g., blue-green).<br>▸ Establish comprehensive monitoring and logging. |

### Prioritized Work Plan

The following table details key tasks for each phase, prioritized to ensure a logical and low-risk migration flow. Tasks should be broken down into smaller, iterative pull requests to facilitate review and testing.

| Phase | Priority | Task | Description |
| :-- | :--- | :--- | :--- |
| **1. Preparation** | High | **Standardize Build Tool** | Decide on a single build system (Maven or Gradle) to simplify the toolchain and CI/CD pipelines. |
| | High | **Update CI to Use JDK 21** | Modify GitHub Actions workflows (`gradle-build.yml`, `maven-build.yml`) to use a stable JDK 21 distribution for all build and test jobs [^3]. |
| | Medium | **Update Build Files for Java 21** | Adjust `pom.xml` and `build.gradle` to set the Java release/toolchain version to `21`. |
| | Medium | **Update Development Environments** | Revise `.devcontainer/devcontainer.json` and `.devcontainer/Dockerfile` to ensure development environments (like Gitpod and VS Code Dev Containers) are based on Java 21 [^4]. |
| **2. Dependencies** | High | **Upgrade Spring Boot Version** | Update the `spring-boot-starter-parent` to the latest stable version that officially supports Java 21. The current `4.0.0-M3` is a milestone release and should be moved to a GA version. |
| | High | **Audit and Update All Dependencies** | Systematically update all third-party dependencies (`webjars`, `checkstyle`, database drivers, etc.) to their latest compatible versions. |
| | Medium | **Resolve `javax` vs. `jakarta` Conflicts** | With the framework upgrade, ensure all dependencies align with the `jakarta.*` namespace, removing any legacy `javax.*` dependencies where a `jakarta` equivalent is available. |
| **3. Code** | High | **Run Static Analysis with Java 21 Rules** | Configure Checkstyle, Error Prone, and any other static analysis tools to use rules for Java 21 and address any reported issues. |
| | Medium | **Address Deprecated Code** | Scan the codebase for usage of any APIs deprecated in Java 17-20 and refactor to use the recommended replacements. |
| | Low | **(Enhancement) Explore Virtual Threads** | Identify I/O-bound operations (e.g., database calls in repositories) and experiment with a virtual-thread-based `TaskExecutor` to improve scalability. |
| **4. Testing** | High | **Execute Full Test Suite** | Run all existing unit, integration, and service tests to confirm that no regressions were introduced. The project already has a strong test foundation [^5][^6]. |
| | High | **Performance Benchmark Testing** | Execute the existing JMeter test plan to establish a performance baseline on Java 17. Rerun the same tests on the Java 21 build to ensure performance is equal or better [^7]. |
| | Medium | **Security Scanning** | Run security vulnerability scans (e.g., CycloneDX Maven/Gradle plugin, OWASP Dependency-Check) on the final set of dependencies to identify and mitigate potential risks [^8]. |
| **5. Deployment** | High | **Build Java 21 Docker Image** | Create a final Docker image for the application using a minimal, production-ready Java 21 base image. |
| | High | **Deploy to Staging Environment on GKE** | Deploy the application and its database backend (migrated to Cloud SQL) to a staging cluster to validate deployment scripts and configuration. |
| | Medium | **User Acceptance Testing (UAT)** | Perform end-to-end manual testing in the staging environment to catch any issues not covered by automated tests. |
| | Medium | **Plan Production Rollout** | Plan a blue-green or canary deployment strategy to enable a zero-downtime release and provide a simple rollback path. |
| | Low | **Establish Cloud Monitoring Dashboards** | Create dashboards in Cloud Monitoring to track key application metrics (e.g., request latency, error rates, JVM heap usage) from Spring Boot Actuator. |

### Testing Strategy

A robust, multi-layered testing strategy is essential for a successful migration. Testing should not be a single phase but an ongoing activity throughout the migration.

-   **Unit Testing:** After any code refactoring, corresponding unit tests must be updated or created. This ensures that the business logic within individual components remains correct. The existing tests in `service/` and `model/` are good examples [^9].
-   **Integration Testing:** This is the most critical part of the testing strategy. The project's existing integration tests, which use Testcontainers to spin up real database instances (MySQL, PostgreSQL), must be run at each major step of the dependency upgrade process [^5][^6]. This will immediately catch issues related to database connectivity, JPA behavior changes, or framework-level regressions.
-   **Performance Testing:** Application performance must be measured before and after the migration. The repository includes a JMeter test plan that provides an excellent foundation for this [^7]. Key metrics to compare include request throughput, response time, and CPU/memory utilization under load.
-   **Security Testing:** With any dependency update, there is a risk of introducing new vulnerabilities. Automated security scanning should be integrated into the CI/CD pipeline to analyze dependencies and ensure the application is secure before deployment.

### Google Cloud Target Architecture & Services

The application's existing container-based architecture makes it an excellent candidate for modernization on Google Cloud. The following services are recommended as a starting point.

#### Compute and Database

| Service | Recommendation | Justification |
| :--- | :--- | :--- |
| **Compute** | **Google Kubernetes Engine (GKE)** | The application is already containerized and includes Kubernetes deployment manifests [^10]. GKE is the natural target, providing a managed environment that automates scaling, simplifies deployments, and integrates seamlessly with other Google Cloud services. |
| **Database** | **Cloud SQL** | The application currently supports running a database inside a container, which is suitable for testing but not for production [^11]. Cloud SQL for PostgreSQL or MySQL is the recommended managed database service. It offloads operational tasks like backups, patching, and replication, providing high availability and reliability. |
| **Future** | **Cloud Run** | While the current monolithic structure is best suited for GKE, if the application is decomposed into microservices in the future, stateless services would be ideal candidates for deployment on Cloud Run for simplified management and scale-to-zero cost efficiency. |

#### Supporting Services

| Service Category | Recommended Service | Purpose |
| :--- | :--- | :--- |
| **CI/CD** | **Cloud Build** | A fully managed CI/CD platform to automate building the Docker image from source, running tests, and deploying the application to GKE. It can be triggered directly from GitHub repository events. |
| **Artifact Storage** | **Artifact Registry** | A central, secure repository for storing and managing the application's Docker images and, optionally, Java build artifacts (JARs). |
| **Observability** | **Cloud Monitoring & Cloud Logging** | Natively integrate with GKE and the application's Spring Boot Actuator endpoints to collect logs, traces, and metrics. This provides deep insight into application performance and health, with capabilities for alerting and custom dashboards. |
| **Secrets Management** | **Secret Manager** | A centralized and secure service for storing database credentials, API keys, and other secrets. The application can be configured with IAM permissions to securely access these secrets at runtime, eliminating the need to store them in Kubernetes Secrets [^12]. |

[^1]: pom.xml: `<maven.compiler.release>17</maven.compiler.release>` - Specifies the target Java release for the Maven build.
[^2]: build.gradle: `languageVersion = JavaLanguageVersion.of(25)` - Configures the Java toolchain version for the Gradle build.
[^3]: .github/workflows/maven-build.yml: `java: [ '25' ]` - The GitHub Actions workflow is currently configured to build with JDK 25.
[^4]: .devcontainer/devcontainer.json: `ghcr.io/devcontainers/features/java:1` - Defines the Java version for the development container.
[^5]: src/test/java/org/springframework/samples/petclinic/MySqlIntegrationTests.java: `MySqlIntegrationTests` - Integration test class using Testcontainers for MySQL.
[^6]: src/test/java/org/springframework/samples/petclinic/PostgresIntegrationTests.java: `PostgresIntegrationTests` - Integration test class using Docker Compose for PostgreSQL.
[^7]: src/test/jmeter/petclinic_test_plan.jmx: `petclinic_test_plan.jmx` - A JMeter test plan for performance testing the application.
[^8]: pom.xml: `cyclonedx-maven-plugin` - The presence of a Software Bill of Materials (SBOM) plugin, which is a key tool for dependency tracking and security analysis.
[^9]: src/test/java/org/springframework/samples/petclinic/service/ClinicServiceTests.java: `ClinicServiceTests` - An example of an existing data-layer integration test.
[^10]: k8s/petclinic.yml: `Deployment` - Kubernetes manifest for deploying the PetClinic application.
[^11]: k8s/db.yml: `Deployment` - Kubernetes manifest for deploying a PostgreSQL database container.
[^12]: k8s/db.yml: `secretKeyRef` - Database credentials are being read from a Kubernetes Secret, which can be replaced by a Secret Manager integration.

